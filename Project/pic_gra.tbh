#ifndef PIC_CLK_PIN
	#define PIC_CLK_PIN PL_IO_NULL
#endif

#ifndef PIC_DATA_PIN
	#define PIC_DATA_PIN PL_IO_NULL
#endif

#ifndef PIC_RST_PIN
	#define PIC_RST_PIN PL_IO_NULL
#endif

#ifndef PIC_INT_PIN
	#define PIC_INT_PIN PL_IO_NULL
#endif


#ifndef TBT_CLK_SOURCE
	#define TBT_CLK_SOURCE INTERNAL_OSCILLATOR_FREQ_32MHZ_HF
#endif

enum pic_result_enum
	PIC_OK,
	PIC_NG,
	PIC_REJ,
	PIC_FWNG
end enum

'ADC input range choices:
enum pic_adc_ref_positive_voltage
	PIC_PREF_SOURCE_VDD,	'(5V nominal), default selection
	PIC_PREF_SOURCE_PIN_4,	'For EM1000LEV only
	PIC_PREF_SOURCE_FVR_BUF	'(Depand on fvr scale)
end enum

enum pic_adc_ref_negative_voltage
	PIC_NREF_SOURCE_VSS,	'Default selection
	PIC_NREF_SOURCE_PIN_5	'For EM1000LEV only
end enum

enum pic_adc_fvr_scale
	PIC_ADC_FVR_REF_OFF,
	PIC_ADC_FVR_REF_2048mV,	'0 ~ 2.048V (based on PIC's internal reference)
	PIC_ADC_FVR_REF_4096mV	'0 ~ 4.096V (based on PIC's internal reference)
end enum

'I/O pin function choices:
enum pic_func_enum
	PIC_FUNC_NULL,			'No function [default selection]
	PIC_FUNC_IO,			'A pin is used as a GPIO, this selection is available for all four pins 0-3
	PIC_FUNC_ADC,			'A pin is used as an ADC input, this selection is available for all four pins 0-3
	PIC_FUNC_PWM,			'A pin is used as a PWM output, this selection is available for pins 0-2. 
	PIC_FUNC_UART			'A pin is used for UART (serial) communications, this selection is available only for pins 0 and 1. Moreover,
							'UART operates ONLY when BOTH pin 0 and pin 1 are configured for UART. If either pin is not in the UART mode
							'then the other pin won't be in the UART mode as well. Pin 0 always works as the RX line, while pin 1 always
							'works as the TX line of the UART.
end enum

'UART parity modes
enum pic_parity_mode_enum
	PIC_PARITY_NONE =&h00,	'[default selection]
	PIC_PARITY_EVEN	=&h40,
	PIC_PARITY_ODD	=&h50,
	PIC_PARITY_MARK	=&h60,
	PIC_PARITY_SPACE=&h70
end enum

Const EXPECTED_PIC_FIRMWARE_V="GRA V00"

declare function pic_init(use_ssi as no_yes, byref fw_str as string)as pic_result_enum
'Call this function to initialize the Tibbit.
'Use_ssi argument specifies whether you want to communicate with this Tibbit using the SSI channel running in the I2C mode (YES), or
'go for direct I/O manipulation a.k.a. bit-banging (NO).
'Note that there is a limited number of SSI channels so if you set use_ssi=YES this function may return TBT16_NJ, meaning that
'there are no free SSI channels left. This doesn't mean failure. Rather, it means that comms will proceed in bit banging mood.
'The use of SSI may also be rejected (TBT16_REJ) if the PIC's clock is at 500KHz. This is because with this low speed PIC micro won't be
'able to handle I2C comms even with the SSI's slowest baudrate.

declare sub pic_config(num as pic_pin_enum, f as pic_func_enum)
'Call this sub to define the IO pin function separately for each pin. Note that somes pins do not support all functions:
'IO -- all pins.
'ADC -- all pins.
'PWM -- pins 0 ~ 2. Pin 3 does not support PWM.
'UART -- pins 0 and 1. Pin 0 is RX, pin 1 is TX. BOTH pins must be configured for UART operation, or neither pin will be in the UART mode.

'---------- I/O ----------
declare sub pic_io_enabled(num as pic_pin_enum, en as no_yes)
'Configures the specified IO pin to be an input (en=NO) or outpur (en=YES).
'This will only work for pins running in the IO mode [see pic_config()]. 

declare sub pic_io_set(num as pic_pin_enum, state as low_high)
'Sets the output state of the specified IO pin.
'This will only work for pins running in the IO mode [see pic_config()] and configured as outputs [see pic_io_enabled()].

declare function pic_io_get(num as pic_pin_enum)as low_high
'Reads the state of the specified IO pin.
'This will only work for pins running in the IO mode [see pic_config()].

'---------- ADC ----------
declare sub pic_adc_config( p as pic_adc_ref_positive_voltage,n as pic_adc_ref_negative_voltage,Vfvr as pic_adc_fvr_scale)
'Configures the input range for all four ADC channels.
'Note that selecting VCC makes inputs "ratiometric" i.e. dependent on the actual VCC voltage value.
'2048mV and 4096mV modes are based on the voltage generated by PIC's internal bandgap reference, which
'generates stable reference voltage that is (almost) not dependant upon the VCC.

declare function pic_adc_get_mv(ch as pic_adc_enum) as word
'Performs ADC conversion for the specified channel and returns conversion result expressed in mV.
'This will only work for channels whose corresponding pins are running in the ADC mode [see pic_config()].
'Conversion range is defined using pic_adc_config() call.

declare function pic_adc_get(ch as pic_adc_enum) as word
'Performs ADC conversion for the specified channel.
'This will only work for pins running in the ADC mode [see pic_config()].
'The range is from 0 (0V) to 1023 (reference), where reference is set with the pic_adc_config() call.

'---------- PWM ----------
declare sub pic_pwm_config(ch as pic_pwm_enum, pulse_width as word, period as word, prescaler as pic_prescaler_enum)
'Sets the operation parameters for the selected PWM channel.
'This will only work for channels whose corresponding pins are running in the PWM mode [see pic_config()].
'Pulse_width is defined as the base frequency clock count. Valid range is from 0 to 1023 in steps of 1 (0,1,2,3...).
'Period is defined as the base frequency clock count. Valid range is from 0 to 1023 in steps of 4 (0,4,8,12...).
'Prescaler affects the base frequency. Available choices are clock frequency divided by 1, 4, 16, or 64.
'The clock frequency is set globally for the entire libriry using the TBT_CLK_SOURCE #define.
'Calling this sub also starts the PWM channel [i.e. you don't need to call pic_pwm_start()].

declare sub pic_pwm_start(ch as pic_pwm_enum)
'Enables PWM output for the specified PWM channel.
'This will only work for channels whose corresponding pins are running in the PWM mode [see pic_config()] and which
'has already been configured with pic_pwm_config().

declare sub pic_pwm_stop(ch as pic_pwm_enum)
'Disables PWM output for the specified PWM channel.
'This will only work for channels whose corresponding pins are running in the PWM mode [see pic_config()].

declare sub pic_pwm_duty(ratio0 as word, ratio1 as word, ratio2 as word)
'Simultaneously sets the duty cycle ratio for all three PWM channels. The ratio for each channel is expressed in
'0.1% units.
'This will only work for channels whose corresponding pins are running in the PWM mode [see pic_config()] and which
'have already been configured with pic_pwm_config().
'Also, the library expects that when this sub is used all three PWM channels are running at the same period.


'---------- UART ---------
declare sub pic_ser_config(br as pic_brate_enum, par as pic_parity_mode_enum, irq_enabled as no_yes)
'Sets the communication parameters for the UART: the baudrate, parity mode, and whether the RX interrupt will be generated
'on the interface line D whenever there is data in the RX buffer. The interrupt is active LOW and, when enabled, stays LOW
'for as long as there is data available in the 64-byte RX buffer.
'UART will only work if BOTH pin 0 (UART RX) and pin 1 (UART TX) are configured for the UART mode. 

declare sub pic_ser_setsend(data as string)
'Sends the string of data out of the serial port. This is a synchronous call: the sub is exited only after all data is sent out.
'For this sub to work, UART must be preset using pic_ser_config() and both pin 0 (UART RX) and pin 1 (UART TX) must be set to run in the UART mode
'[see pic_config()].

declare function pic_ser_get() as string
'Reads data from PIC's RX buffer. The buffer is maintained by the GRA firmware and can fit up to 64 bytes.
'For this sub to work, UART must be preset using pic_ser_config() and both pin 0 (UART RX) and pin 1 (UART TX) must be set to run in the UART mode
'[see pic_config()].

declare function pic_ser_txlen()as byte
'Returns the number of bytes currently waiting in the TX buffer. The buffer is maintained by the GRA firmware and can fit up to 80 bytes.

declare function pic_ser_rxlen()as byte
'Returns the number of bytes currently waiting in the RX buffer. The buffer is maintained by the GRA firmware and can fit up to 80 bytes.